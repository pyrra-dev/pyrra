# Task 7.10.2: Implementation Guide

## Quick Reference

This guide provides the essential information needed to implement the BurnRateThresholdDisplay optimization based on Task 7.10.1 validation results.

## Validation Results Summary

From `.dev-docs/TASK_7.10_VALIDATION_RESULTS.md`:

| Indicator | Current (Raw) | Optimized (Recording Rule) | Speedup | Action |
|-----------|---------------|---------------------------|---------|--------|
| **Ratio** | 48.75ms | 6.80ms | **7.17x** | ✅ IMPLEMENT |
| **Latency** | 6.34ms | 2.89ms | **2.20x** | ✅ IMPLEMENT |
| **BoolGauge** | 3.02ms | 4.14ms | **0.73x** | ❌ SKIP |

## Critical Understanding

### Recording Rule Availability

**What EXISTS**:
- ✅ SLO window recording rules (e.g., `metric:increase30d`, `metric:increase28d`)
- ✅ Generated by Pyrra backend for each SLO
- ✅ Pre-computed every 30 seconds

**What DOES NOT EXIST**:
- ❌ Alert window recording rules (1h4m, 6h26m, 1d1h43m, 4d6h51m)
- ❌ No `metric:increase1h4m` or similar for alert windows
- ❌ Must use inline `increase()` calculations for alert windows

### Hybrid Approach Required

```typescript
// CORRECT: Hybrid approach
const sloWindowQuery = `sum(metric:increase30d{slo="${sloName}"})`;  // Recording rule
const alertWindowQuery = `sum(increase(metric[1h4m]))`;              // Inline calculation
const trafficRatio = `${sloWindowQuery} / ${alertWindowQuery}`;

// WRONG: Trying to use recording rules for alert windows
const alertWindowQuery = `sum(metric:increase1h4m{slo="${sloName}"})`;  // DOES NOT EXIST
```

## Implementation Steps

### 1. Add Helper Function: getBaseMetricName()

**Purpose**: Strip suffixes to get recording rule base name

```typescript
function getBaseMetricName(metric: string): string {
  return metric
    .replace(/_total$/, '')
    .replace(/_count$/, '')
    .replace(/_bucket$/, '');
}

// Examples:
// apiserver_request_total → apiserver_request
// prometheus_http_request_duration_seconds_count → prometheus_http_request_duration_seconds
```

### 2. Add Function: getTrafficRatioQueryOptimized()

**Purpose**: Generate hybrid query using recording rule for SLO window

```typescript
function getTrafficRatioQueryOptimized(
  objective: Objective,
  factor: number
): string {
  const sloName = objective.labels?.__name__ ?? "unknown";
  const baseMetric = getBaseMetricName(getBaseMetricSelector(objective));
  
  const windowMap = {
    14: { slo: "30d", alert: "1h4m" },
    7: { slo: "30d", alert: "6h26m" },
    2: { slo: "30d", alert: "1d1h43m" },
    1: { slo: "30d", alert: "4d6h51m" },
  };
  
  const windows = windowMap[factor];
  if (!windows) return "";
  
  // Hybrid approach: recording rule for SLO window + inline for alert window
  const sloWindowQuery = `sum(${baseMetric}:increase${windows.slo}{slo="${sloName}"})`;
  const alertWindowQuery = `sum(increase(${getBaseMetricSelector(objective)}[${windows.alert}]))`;
  
  return `${sloWindowQuery} / ${alertWindowQuery}`;
}
```

### 3. Update getTrafficRatioQuery()

**Purpose**: Use optimized query for ratio and latency, fallback for others

```typescript
const getTrafficRatioQuery = (factor: number): string => {
  const indicatorType = getIndicatorType(objective);
  
  // Use optimization for ratio and latency (validated speedup)
  if (indicatorType === 'ratio' || indicatorType === 'latency') {
    const optimizedQuery = getTrafficRatioQueryOptimized(objective, factor);
    if (optimizedQuery) {
      return optimizedQuery;
    }
  }
  
  // Fallback to raw metrics for boolGauge or if optimization fails
  const windows = windowMap[factor as keyof typeof windowMap];
  if (windows === undefined) return "";
  
  const baseSelector = getBaseMetricSelector(objective);
  // ... existing raw metric query generation
};
```

## Query Patterns by Indicator Type

### Ratio Indicators

**Current (Raw)**:
```promql
sum(increase(apiserver_request_total[30d])) / sum(increase(apiserver_request_total[1h4m]))
```

**Optimized (Hybrid)**:
```promql
sum(apiserver_request:increase30d{slo="test-dynamic-apiserver"}) / sum(increase(apiserver_request_total[1h4m]))
```

**Performance**: 48.75ms → 6.80ms (7.17x speedup)

### Latency Indicators

**Current (Raw)**:
```promql
sum(increase(prometheus_http_request_duration_seconds_count[30d])) / sum(increase(prometheus_http_request_duration_seconds_count[1h4m]))
```

**Optimized (Hybrid)**:
```promql
sum(prometheus_http_request_duration_seconds:increase30d{slo="test-latency-dynamic"}) / sum(increase(prometheus_http_request_duration_seconds_count[1h4m]))
```

**Performance**: 6.34ms → 2.89ms (2.20x speedup)

### BoolGauge Indicators

**Current (Raw)**:
```promql
sum(count_over_time(up{job="prometheus-k8s"}[30d])) / sum(count_over_time(up{job="prometheus-k8s"}[1h4m]))
```

**Optimized**: NOT RECOMMENDED
- Already fast at 3.02ms
- No performance benefit observed
- Skip optimization for boolGauge

## Testing Strategy

### 1. Unit Tests (Optional per task spec)

Test helper functions:
- `getBaseMetricName()` - suffix stripping
- `getTrafficRatioQueryOptimized()` - query generation

### 2. Manual Testing

Use validation tool from Task 7.10.1:
```bash
./validate-ui-query-optimization.exe
```

Expected results:
- Ratio queries: ~7x speedup
- Latency queries: ~2x speedup
- No errors or failed queries

### 3. UI Testing

1. Start development UI: `cd ui && npm start`
2. Navigate to dynamic SLO detail page
3. Check BurnRateThresholdDisplay component
4. Verify thresholds display correctly
5. Check browser console for query execution times

## Fallback Strategy

Always include fallback to raw metrics:

```typescript
function getTrafficRatioQueryOptimized(objective: Objective, factor: number): string {
  try {
    // Try to generate optimized query
    const sloName = objective.labels?.__name__;
    if (!sloName) {
      return ""; // Fallback to raw metrics
    }
    
    // ... generate optimized query
    return optimizedQuery;
  } catch (error) {
    console.warn("Failed to generate optimized query, falling back to raw metrics", error);
    return ""; // Fallback to raw metrics
  }
}
```

## Common Pitfalls to Avoid

### ❌ DON'T: Try to use recording rules for alert windows
```typescript
// WRONG - alert windows don't have recording rules
const alertQuery = `sum(metric:increase1h4m{slo="..."})`;
```

### ❌ DON'T: Optimize boolGauge indicators
```typescript
// WRONG - no performance benefit
if (indicatorType === 'boolGauge') {
  return getTrafficRatioQueryOptimized(objective, factor);
}
```

### ❌ DON'T: Forget to strip metric suffixes
```typescript
// WRONG - recording rule name won't match
const recordingRule = `apiserver_request_total:increase30d`;  // Should be apiserver_request:increase30d
```

### ✅ DO: Use hybrid approach
```typescript
// CORRECT - recording rule for SLO window, inline for alert window
const query = `sum(metric:increase30d{slo="..."}) / sum(increase(metric[1h4m]))`;
```

### ✅ DO: Include fallback logic
```typescript
// CORRECT - fallback to raw metrics if optimization fails
const optimizedQuery = getTrafficRatioQueryOptimized(objective, factor);
if (optimizedQuery) {
  return optimizedQuery;
}
// Fallback to raw metrics
return getRawMetricQuery(objective, factor);
```

### ✅ DO: Test with actual SLOs
```typescript
// CORRECT - test with real Prometheus data
// Use test-dynamic-apiserver and test-latency-dynamic SLOs
```

## Success Criteria

- [ ] Ratio indicator queries use recording rule for SLO window
- [ ] Latency indicator queries use recording rule for SLO window
- [ ] Alert windows continue using inline increase() calculations
- [ ] BoolGauge indicators use raw metrics (no optimization)
- [ ] Fallback to raw metrics works when recording rules unavailable
- [ ] No TypeScript compilation errors
- [ ] Validation tool shows expected speedup (7x for ratio, 2x for latency)
- [ ] UI displays thresholds correctly
- [ ] No console errors in browser

## Reference Documents

- **Validation Results**: `.dev-docs/TASK_7.10_VALIDATION_RESULTS.md`
- **Analysis**: `.dev-docs/TASK_7.10_UI_QUERY_OPTIMIZATION_ANALYSIS.md`
- **Test Improvements**: `.dev-docs/TASK_7.10.1_TEST_IMPROVEMENTS.md`
- **Component**: `ui/src/components/BurnRateThresholdDisplay.tsx`
- **Helper Functions**: `ui/src/burnrate.tsx`

## Next Steps After Implementation

1. Run validation tool to confirm performance improvement
2. Test in development UI (port 3000)
3. Document implementation in `.dev-docs/TASK_7.10_IMPLEMENTATION.md`
4. Update task 7.10.4 with actual performance measurements
5. Consider backend optimization in task 7.10.3
